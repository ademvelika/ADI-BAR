<#@ Include File="TemplateHeader.t4" #>
<#@ Modeling ElementType="Microsoft.VisualStudio.Uml.Classes.IClass" Processor="ModelingProcessor" ApplyStereotypes="CSharp" #>
<#@ Import Namespace="Microsoft.VisualStudio.Uml.Classes" #>
<#@ Import Namespace="Microsoft.VisualStudio.ArchitectureTools.Extensibility.Uml" #>
<#@ Include File="..\CSharpCommentHelpers.t4" #>
<#@ Include File="..\CSharpHelpers.t4" #>
<#@ Output Extension=".cs" #>
<# 
    WriteAutoGeneratedWarningHeader();

    string structNamespace = GetNamespace(this.Element.Namespace);
    if(!string.IsNullOrEmpty(structNamespace))
    {
#>
namespace <#= structNamespace #>
{
<#
        PushIndent("\t");
    }

    WriteUsingStatements(this.Element);
    WriteLine("");
#>
<#
    WriteSummaryComment(this.Element.Description);
    WriteTemplateTypeParameterComments(TemplateParameterNameDescriptionPairs(this.Element));
    foreach(var comment in this.Element.GetModelStore().AllInstances<IComment>().Where(c => c.AnnotatedElements.Contains(this.Element)))
    {
        WriteRemarksComment(comment.Body);
    }
#>
<# 
    WriteStructClrAttributes(this.Element); 
#>
<#= StructVisibility(this.Element) #><#= StructUnsafeOption(this.Element) #><#= StructPartialOption(this.Element) #>struct <#= ClassifierName(this.Element) #><#= InterfaceRealizationList(Element) #><# WriteClassifierConstraintOption(this.Element); #>
{
<#
    PushIndent("\t");

    // Write Attributes
	var ownedAttributes = this.Element.OwnedAttributes;
    foreach(IProperty attribute in ownedAttributes)
    {
        WriteSummaryComment(attribute.Description);
        WriteStructUmlPropertyDefinition(attribute);
		WriteLine("");
    }
#>
<#
    // Write Associations
	var navigableOwnedEnds = GetNavigableOwnedEnds(this.Element, ownedAttributes);
    foreach(IProperty ownedEnd in navigableOwnedEnds) 
    {
        WriteSummaryComment(ownedEnd.OwningAssociation.Description);
        WriteSummaryComment(ownedEnd.Description);
        WriteStructUmlPropertyDefinition(ownedEnd);
        WriteLine("");
    }
#>
<#
    // Write Operations
    foreach(IOperation operation in this.Element.OwnedOperations)
    {
        WriteSummaryComment(operation.Description);
        foreach (IParameter parameter in operation.OwnedParameters.Where(p => p.Direction != ParameterDirectionKind.Return))
        {
            WriteParameterComment(parameter.Name, parameter.Description);
        }

        if(GetStereotype(operation) == "method")
        {
            WriteMethodClrAttributes(operation);
            if(IsConstructor(operation))
            {
#>
<#= MethodVisibility(operation) #><#= operation.Name #>(<# WriteMethodParameterList(operation); #>)
{
}
<#
            }
            else
            {
#>
<#= MethodVisibility(operation) #><#= MethodUnsafeOption(operation) #><#= OperationStaticOption(operation) #><#= MethodPartialOption(operation) #><#= MethodType(operation) #> <#= operation.Name #>(<# WriteMethodParameterList(operation); #>)<# WriteStructMethodBody(operation); #>
<#
            }

			WriteLine("");
        }
        else if(GetStereotype(operation) == "indexer") 
        {
            WriteIndexerClrAttributes(operation);
#>
<#= IndexerVisibility(operation) #><#= IndexerUnsafeOption(operation) #><#= OperationStaticOption(operation) #><#= IndexerType(operation) #> this[<# WriteIndexerParameterList(operation); #>]
{
<#
            PushIndent("\t");
#>
<#= IndexerGetVisibility(operation) #>get<# WriteStructIndexerAccessorBody(operation); #>
<#= IndexerSetVisibility(operation) #>set<# WriteStructIndexerAccessorBody(operation); #>
<#
            PopIndent();
#>
}
<#
            WriteLine("");
        }
    }

    PopIndent();
#>
}
<# 
    ClearIndent(); 
    if(!string.IsNullOrEmpty(structNamespace))
    {
#>
}
<#  } #>

<#+

    /// <summary>
    /// Write UmlProperty definition.
    /// </summary>
    /// <param name="property">The uml IProperty</param>
    private void WriteStructUmlPropertyDefinition(IProperty property)
    {
        WriteUmlPropertyDefinition(property);
    }

    /// <summary>
    /// Write the method body for struct. Note that if the method is partial, it can't have the method body, 
    /// otherwise struct method always has the body as abstract doesn't make sense,
    /// </summary>
    /// <param name="operation">The operation</param>
    private void WriteStructMethodBody(IOperation operation)
    { 
        if(string.IsNullOrEmpty(MethodPartialOption(operation)))
        {
            WriteDefaultImplementation();
        }
        else 
        {
            Write(";");
            WriteLine("");
        }
    }

    /// <summary>
    /// Write the indexer accessor body
    /// </summary>
    /// <param name="operation">The operation</param>
    private void WriteStructIndexerAccessorBody(IOperation operation)
    {
        WriteStructMethodBody(operation);
    }

    #region Inheritance

    /// <summary>
    /// Get the implemented and inherited types of the given class
    /// </summary>
    /// <param name="aClass">The given class</param>
    /// <returns>implementedAndInherted types</returns>
    public static IEnumerable<IType> InterfaceRealization(IClass aClass)
    {
        return aClass.InterfaceRealizations.Select(ir => ir.Contract);
    }

    /// <summary>
    /// Get the implemented and inherited types of the given class
    /// </summary>
    /// <param name="aClass">The given class</param>
    /// <returns>implementedAndInherted types</returns>
    public static string InterfaceRealizationList(IClass aClass)
    {
        var list = InterfaceRealization(aClass);
        if(list.Any())
        {
            return " : " + string.Join(", ", list.Select(t => ElementType(t)));
        }
        else
        {
            return string.Empty;
        }
    }

    #endregion Inheritance

    #region Struct property options

    private static string StructUnsafeOption(IClass element)
    {
        return GetProperty(element, "struct", "IsUnsafe", "unsafe");
    }

    private static string StructStaticOption(IClass element) 
    {
        return GetProperty(element, "struct", "IsStatic", "static");
    }

    private static string StructPartialOption(IClass element)
    {
        return GetProperty(element, "struct", "IsPartial", "partial");
    }

    #endregion Struct property options
    
    #region Visibility

    /// <summary>
    /// Returns the visibility of the given struct
    /// </summary>
    /// <param name="aStruct">a Struct</param>
    /// <returns>string visibility</returns>
    private static string StructVisibility(IClass aStruct)
    {
        return Visibility(aStruct, "struct", "PackageVisibility");
    }
 
    #endregion Visibility

#>
<#+
    protected override bool AppliesToElement()
    {        
        bool isTemplate = this.Element.IsTemplate;
        bool isBoundElement = this.Element.TemplateBindings != null && this.Element.TemplateBindings.Any();
        return !isTemplate && !isBoundElement && GetStereotype(this.Element) == "struct";
    }
#>
